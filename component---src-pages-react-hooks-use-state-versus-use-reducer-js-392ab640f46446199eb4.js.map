{"version":3,"sources":["webpack:///./src/pages/react-hooks-useState-versus-useReducer.js"],"names":["Entry","title","class","style","fontStyle"],"mappings":"2FAAA,wDAgHeA,UA5GD,WACZ,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAKC,MAAM,aACX,wEACA,6BACA,2VAOA,gJAE2C,0CAF3C,qFAKA,4QAMA,yBAAKC,MAAM,gBACT,0BAAMA,MAAM,gBAAZ,6cAqBF,yDAC6B,0CAD7B,sGAGY,4CAHZ,MAKA,oFACyD,IACvD,4CAFF,0LAIkE,IAChE,0BAAMC,MAAO,CAAEC,UAAW,WAA1B,QALF,+CAQA,sHAEoB,0CAFpB,0HAIoB,0CAJpB,KAMA,yBAAKF,MAAM,gBACT,0BAAMA,MAAM,gBAAZ,uaA8BF,0IAIA","file":"component---src-pages-react-hooks-use-state-versus-use-reducer-js-392ab640f46446199eb4.js","sourcesContent":["import React from \"react\"\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\n\nconst Entry = () => {\n  return (\n    <Layout>\n      <SEO title=\"Page two\" />\n      <h1>React Hooks - useState versus useReducer</h1>\n      <hr />\n      <p>\n        Like many a React developer who preferred function components to\n        classes, I was excited to begin implementing React Hooks upon their\n        release in early 2019. Upon reflection of over a year spent using\n        stateful function components consistenly, much has changed in my\n        philosophy on how I approach such an implementation.\n      </p>\n      <p>\n        My first attemps were quite inelegant. I began building a component, and\n        when I needed a state variable, I called <code>useState</code>. When I\n        needed a second state variable, I called it again. And again. And again.\n      </p>\n      <p>\n        Let's take the example of a registration form with numerous controlled\n        inputs and a modal that appears on a certain user action (maybe their\n        password is invalid). After a while, the top of such a component often\n        begins to look like this:\n      </p>\n      <pre class=\"language-jsx\">\n        <code class=\"language-jsx\">\n          {`import React, { useState } from 'react';\n\nconst MyForm = () => {\n  const [modalVisible, setModalVisibility] = useState(false);\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [email, setEmail] = useState('');\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  \n  return (\n    <form>\n      ...\n    </form>\n  )\n}\n\nexport default MyForm;`}\n        </code>\n      </pre>\n      <p>\n        \"This is too many calls to <code>useState</code>; the top of my\n        component is cluttered and repetitive,\" I would decide. \"Time to convert\n        this to a <code>useReducer</code>.\"\n      </p>\n      <p>\n        Although I presently still often end up preferring the{\" \"}\n        <code>useReducer</code> hook, my reasoning has evolved, and the false\n        dichotomy I had created about being forced to choose between the two has\n        shifted into a new and better understanding: often times, using{\" \"}\n        <span style={{ fontStyle: \"italic\" }}>both</span> hooks in one component\n        is the best answer.\n      </p>\n      <p>\n        Let's again take our form with a modal. Armed with our philosophy of\n        \"combine multiple <code>useState</code> calls when we've exceed an\n        arbitrary number of them\", we proceed with refactoring our component to\n        no longer require <code>useState</code>.\n      </p>\n      <pre class=\"language-jsx\">\n        <code class=\"language-jsx\">\n          {`import React, { useReducer } from 'react';\n\nconst initialState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  modalVisible: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    ...\n  }\n}\n\nconst MyForm = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <form>\n      ...\n    </form>\n  )\n}\n\nexport default MyForm;`}\n        </code>\n      </pre>\n      <p>\n        Okay; we refactored some things. Did we improve our component? By which\n        metric did we improve or get worse?\n      </p>\n      <p>\n        The answer becomes clearer when we begin to modify our component (or,\n        better yet, when a teammate goes to modify it later).\n      </p>\n    </Layout>\n  )\n}\n\nexport default Entry\n"],"sourceRoot":""}