(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{bCok:function(e,t,n){"use strict";n.r(t);var a=n("q1tI"),o=n.n(a),s=n("Bl7J"),r=n("vrFN");t.default=function(){return o.a.createElement(s.a,null,o.a.createElement(r.a,{title:"React Hooks - useState versus useReducer"}),o.a.createElement("h1",null,"React Hooks - useState versus useReducer"),o.a.createElement("hr",null),o.a.createElement("p",null,"Like many a React developer who preferred function components to classes, I was excited to begin implementing React Hooks upon their release in early 2019. Upon reflection of over a year spent consistently writing stateful function components, much has changed in my philosophy on how I approach such an implementation."),o.a.createElement("p",null,"My first attemps were quite inelegant. I began building a component, and when I needed a state variable, I called ",o.a.createElement("code",null,"useState"),". When I needed a second state variable, I called it again. And again. And again."),o.a.createElement("p",null,"Let's take the example of a registration form with numerous controlled inputs and a modal that appears on a certain user action (maybe their password is invalid). Let's say we also have a toggle that allows the user to switch the form between light mode and dark mode. After a while, the top of such a component often begins to look like this:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useState } from 'react';\nimport Modal from 'some-modal-library';\nimport Toggle from '../Toggle';\n\nconst MyForm = () => {\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [email, setEmail] = useState('');\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [modalVisible, setModalVisibility] = useState(false);\n  const [darkMode, setDarkMode] = useState(false);\n  \n  return (\n    <div className={darkMode ? 'dark' : 'light}>\n     <Toggle onToggle={setDarkMode(!darkMode)} />\n      <form>\n        <label>First Name</label>\n        <input type=\"text\" onChange={e => setFirstName(e.target.value)} value={firstName} />\n        // ...\n      </form>\n      <Modal open={modalVisible}>\n        Password must contain at least one number and one letter\n      </Modal>\n    </div>\n  )\n}\n\nexport default MyForm;")),o.a.createElement("p",null,'"This is too many calls to ',o.a.createElement("code",null,"useState"),'; the top of my component is cluttered and repetitive," I would decide. "Time to convert this to use the ',o.a.createElement("code",null,"useReducer"),' hook." Although I often end up preferring the ',o.a.createElement("code",null,"useReducer")," hook, my reasoning has evolved, and the false dichotomy I had created about being forced to choose between the two has shifted into a new and better understanding: often times, using ",o.a.createElement("span",{style:{fontStyle:"italic"}},"both")," hooks in one component is the best answer."),o.a.createElement("p",null,"Let's again look at our registration form with a modal. Armed with our philosophy of \"combine multiple ",o.a.createElement("code",null,"useState")," calls when we've exceeded an arbitrary number of them\", we proceed with refactoring our component to no longer require ",o.a.createElement("code",null,"useState"),"."),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useReducer } from 'react';\nimport Modal from 'some-modal-library';\nimport Toggle from '../Toggle';\n\nconst initialState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  password: '',\n  modalVisible: false,\n  darkMode: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    case 'set first name':\n      return {\n        ...state,\n        firstName: action.payload\n      };\n    // ...  \n    default: \n      return state;\n  }\n}\n\nconst MyForm = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    // ...\n    <input \n      type=\"text\" \n      onChange={\n        e => dispatch({ type: 'set first name', payload: e.target.value })\n      }\n      value={state.firstName}\n    />\n    // ...\n    <Modal open={state.modalVisible}>\n    // ...")),o.a.createElement("p",null,"Okay; we refactored some things. Did we improve our component? By which metric did we improve or get worse? The answer becomes clearer when we begin to modify our component (or, better yet, when a teammate goes to modify it later)."),o.a.createElement("p",null,"A teammate is given this component and asked to add a Reset button to the form. If provided the first version, the result would likely look like this:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useState } from 'react';\nimport Modal from 'some-modal-library';\n\nconst MyForm = () => {\n  // ...\n  const onResetClick = () => {\n    setFirstName('');\n    setLastName('');\n    setEmail('');\n    setUsername('');\n    setPassword('');\n  }\n\n  return (\n    // ...\n    <button onClick={onResetClick}>Reset</button>\n    // ...\n  )")),o.a.createElement("p",null,"That looks rather suboptimal. Wouldn't it be nice if we could batch those calls to set fields into a single command? Naturally, that's exactly what we do with the ",o.a.createElement("code",null,"useReducer")," version of the component:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useReducer } from 'react';\nimport Modal from 'some-modal-library';\nimport Toggle from '../Toggle';\n\nconst initialState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  password: '',\n  modalVisible: false,\n  darkMode: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    // ...\n    case 'reset form':\n      return {\n        ...initialState\n      }\n    // ...\n  }\n}\n\nconst MyForm = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    // ...\n    <button onClick={() => dispatch({ type: 'reset form' })}>Reset</button>")),o.a.createElement("p",null,"Great! Thanks, teammate!"),o.a.createElement("p",null,"Except..."),o.a.createElement("p",null,"Now you've reset the form to light mode. :facepalm:"),o.a.createElement("p",null,"Perhaps I'm not giving this imaginary teammate enough credit. Perhaps they looked at ",o.a.createElement("code",null,"initialState")," and saw that the"," ",o.a.createElement("code",null,"darkMode")," boolean was included (not to mention the modal visibility boolean). In that case, they may have written their reducer solution to look like this:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"// ...\nconst initialState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  password: '',\n  modalVisible: false,\n  darkMode: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    // ...\n    case 'reset form':\n      return {\n        ...state,\n        firstName: '',\n        lastName: '',\n        email: '',\n        username: '',\n        password: ''\n      }\n    // ...\n  }\n}")),o.a.createElement("p",null,"This brings us back to our question: did we make our component better when we moved every ",o.a.createElement("code",null,"useState")," call into a single"," ",o.a.createElement("code",null,"useReducer"),"? I would posit that we have not. We've simply moved the verbosity from the top of the component to the state/reducer portion of our file. Additionally, we're mixing concerns. The form inputs' contents need not know the color scheme of the page and vice versa (nor is the visibility of the modal inherently tied to the form's values)."),o.a.createElement("p",null,"A clever developer might suggest this as an alternative:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"// ...\nconst initialFormState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  password: '',\n}\n\nconst initialNonFormState = {\n  modalVisible: false,\n  darkMode: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    // ...\n    case 'reset form':\n      return {\n        ...state,\n        ...initialFormState\n      }\n    // ...\n  }\n\n  // ...\n  const [state, dispatch] = useReducer(reducer, { ...initialFormState, ...initialNonFormState })\n          ")),o.a.createElement("p",null,"Clever as this may be, we're still mixing concerns and not giving a person new to this component the best chance of understanding the functionality with the least amount of difficulty."),o.a.createElement("p",null,"Let us finally arrive at what I believe to be the optimal solution:"," ",o.a.createElement("code",null,"useState")," for singleton state variables combined with a"," ",o.a.createElement("code",null,"useReducer")," for state variables that are associated with one another or dependant on one another in some way."),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useState, useReducer } from 'react';\nimport Modal from 'some-modal-library';\nimport Toggle from '../Toggle';\n\nconst initialFormState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  password: ''\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    case 'set first name':\n      return {\n        ...state,\n        firstName: action.payload\n      };\n    case 'reset form':\n      return {\n        ...initialFormState\n      }\n    // ...\n    default: \n      return state;\n  }\n}\n\nconst MyForm = () => {\n  const [formState, dispatch] = useReducer(reducer, initialFormState);\n  const [darkMode, setDarkMode] = useState(false);\n  const [modalVisible, setModalVisibilitiy] = useState(false);\n  \n  return (\n    <div className={darkMode ? 'dark' : 'light}>\n     <Toggle onToggle={setDarkMode(!darkMode)} />\n      <form>\n        <label>First Name</label>\n        <input \n          type=\"text\" \n          onChange={\n            e => dispatch({ type: 'set first name', payload: e.target.value })\n          }\n          value={formState.firstName}\n        />\n        // ...\n        <button onClick={() => dispatch({ type: 'reset form' })}>Reset</button>\n      </form>\n      <Modal open={modalVisible}>\n        Password must contain at least one number and one letter\n      </Modal>\n    </div>\n  )\n}\n\nexport default MyForm;")),o.a.createElement("p",null,"Your average React developer who has worked with Hooks even a little will likely grasp this component and be able to add functionality or debug issues with much less difficulty than any of the previous examples (and less likelihood of adding new bugs themselves)."),o.a.createElement("hr",null),o.a.createElement("p",null,"Do you agree? Disagree? Do you have an even better approach that I haven't discovered?"," ",o.a.createElement("a",{href:"mailto:marc.gray@graybox.co"},"Drop me a line.")," :)"))}}}]);
//# sourceMappingURL=component---src-pages-react-hooks-use-state-versus-use-reducer-js-a0c9e7a0e68d53db97db.js.map