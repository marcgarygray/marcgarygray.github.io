(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{bCok:function(e,t,n){"use strict";n.r(t);var a=n("q1tI"),o=n.n(a),r=n("Bl7J"),s=n("vrFN");t.default=function(){return o.a.createElement(r.a,null,o.a.createElement(s.a,{title:"Page two"}),o.a.createElement("h1",null,"React Hooks - useState versus useReducer"),o.a.createElement("hr",null),o.a.createElement("p",null,"Like many a React developer who preferred function components to classes, I was excited to begin implementing React Hooks upon their release in early 2019. Upon reflection of over a year spent consistently writing stateful function components, much has changed in my philosophy on how I approach such an implementation."),o.a.createElement("p",null,"My first attemps were quite inelegant. I began building a component, and when I needed a state variable, I called ",o.a.createElement("code",null,"useState"),". When I needed a second state variable, I called it again. And again. And again."),o.a.createElement("p",null,"Let's take the example of a registration form with numerous controlled inputs and a modal that appears on a certain user action (maybe their password is invalid). After a while, the top of such a component often begins to look like this:"),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useState } from 'react';\n\nconst MyForm = () => {\n  const [modalVisible, setModalVisibility] = useState(false);\n  const [firstName, setFirstName] = useState('');\n  const [lastName, setLastName] = useState('');\n  const [email, setEmail] = useState('');\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  \n  return (\n    <form>\n      ...\n    </form>\n  )\n}\n\nexport default MyForm;")),o.a.createElement("p",null,'"This is too many calls to ',o.a.createElement("code",null,"useState"),'; the top of my component is cluttered and repetitive," I would decide. "Time to convert this to use the ',o.a.createElement("code",null,"useReducer"),' hook."'),o.a.createElement("p",null,"Although I often end up preferring the ",o.a.createElement("code",null,"useReducer")," hook, my reasoning has evolved, and the false dichotomy I had created about being forced to choose between the two has shifted into a new and better understanding: often times, using"," ",o.a.createElement("span",{style:{fontStyle:"italic"}},"both")," hooks in one component is the best answer."),o.a.createElement("p",null,"Let's again look at our registration form with a modal. Armed with our philosophy of \"combine multiple ",o.a.createElement("code",null,"useState")," calls when we've exceed an arbitrary number of them\", we proceed with refactoring our component to no longer require ",o.a.createElement("code",null,"useState"),"."),o.a.createElement("pre",{class:"language-jsx"},o.a.createElement("code",{class:"language-jsx"},"import React, { useReducer } from 'react';\n\nconst initialState = {\n  firstName: '',\n  lastName: '',\n  email: '',\n  username: '',\n  modalVisible: false\n}\n\nconst reducer = (state, action) => {\n  switch(action.type) {\n    ...\n  }\n}\n\nconst MyForm = () => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  \n  return (\n    <form>\n      ...\n    </form>\n  )\n}\n\nexport default MyForm;")),o.a.createElement("p",null,"Okay; we refactored some things. Did we improve our component? By which metric did we improve or get worse?"),o.a.createElement("p",null,"The answer becomes clearer when we begin to modify our component (or, better yet, when a teammate goes to modify it later)."))}}}]);
//# sourceMappingURL=component---src-pages-react-hooks-use-state-versus-use-reducer-js-5b68b0d1c2f1c3ff7ad1.js.map